#include <iostream>
#include <vector>

int main()
{
	
	std::vector <int> ivector = {2, 4, 7, 9, 11, 15}; 
	std::vector <int> jvector = { 1, 2 };
	jvector = ivector; // оператор  =  заменяет элементы вектора (слева от = )  копией другого вектора
	std::cout << ivector[0] << std::endl; // оператор  []  возвращает ссылку на элемент вектора в указанной позиции

	ivector.push_back(5);
	ivector.push_back(6);
	ivector.push_back(7);

	ivector.erase(ivector.begin(), ivector.end() - 2); // удаляет элементы, в данной перегрузке с позиции 1 аргумента до позиции 2 аргумента

	ivector.insert(ivector.begin(), 5); // вставляет значение ( 2 аргумент)  в указанную позицию ( 1 аргумент)

	ivector.emplace_back(9); /* push_back добавляет копию объекта в конец, а emplace_back создаёт объект непосредственно в конце вектора
	                         т.е emplace_back оптимизированнее */

	ivector.resize(20,8); /* первый аргумент определяет количество первых элементов, второй аргумент заменит недостающие элементы,
	                          если размер вектора меньше первого аргумента */

	ivector.reserve(100); /* reserve подготавливает место для последующего заполнения, не изменяя размер вектора,
	                    позволяет отслеживать реальную заполненность вектора и ,как следствие, он оптимизированнее resize */

	ivector.shrink_to_fit(); // уменьшает кол-во используемой вектором памяти, если она не используется
    std::cout << ivector.capacity() << std::endl; // показывает кол-во элементов, которое может содержать вектор до того, как потребуется выделить больше места

	ivector.clear(); // уничтожает все элементы вектора, сохраняя выделенную на них память
	std::cout << ivector.size(); /* размер вектора = 0, т.к size возвращает кол - во элементов в векторе, которое он содержит,
	                             а мы их уничтожили функцией clear, но кол-во выделенной памяти ( capacity ) останется той же */
	
	
}

